"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseConnection = void 0;
const handleError_1 = require("./handleError");
const jdbcstream_1 = require("./jdbcstream");
const jdbcwritestream_1 = require("./jdbcwritestream");
function convertDateValues(v) {
    return v instanceof Date
        ? v.toISOString().replace('T', ' ').replace('Z', '')
        : v;
}
function paramsToJson(params) {
    return JSON.stringify((params || []).map(convertDateValues));
}
const createBaseConnection = function (jdbcConnection, insertListFun, inMemory) {
    const baseConnection = {
        query(sql, params, options) {
            const jsonParams = paramsToJson(params || []);
            const trim = options && options.trim !== undefined ? options.trim : true;
            return jdbcConnection
                .query(sql, jsonParams, trim)
                .then(JSON.parse)
                .catch((0, handleError_1.handleError)({ sql, params }));
        },
        createReadStream(sql, params) {
            const jsonParams = paramsToJson(params || []);
            return new jdbcstream_1.JdbcStream({
                jdbcStreamPromise: jdbcConnection
                    .queryAsStream(sql, jsonParams, 100)
                    .catch((0, handleError_1.handleError)({ sql, params })),
            });
        },
        execute(sql, params) {
            const jsonParams = paramsToJson(params || []);
            return jdbcConnection
                .execute(sql, jsonParams)
                .then((statement) => {
                const isQuery = statement.isQuerySync();
                let stream;
                const stWrap = {
                    isQuery() {
                        return isQuery;
                    },
                    metadata() {
                        return statement.getMetaData().then(JSON.parse);
                    },
                    asArray() {
                        return statement.asArray().then(JSON.parse);
                    },
                    asStream(options) {
                        options = options || {};
                        stream = new jdbcstream_1.JdbcStream({
                            jdbcStream: statement.asStreamSync(options.bufferSize || 100),
                        });
                        return stream;
                    },
                    asIterable() {
                        return {
                            [Symbol.asyncIterator]() {
                                return {
                                    next() {
                                        return __awaiter(this, void 0, void 0, function* () {
                                            return statement
                                                .next()
                                                .then(JSON.parse)
                                                .then((value) => ({
                                                done: !Boolean(value),
                                                value,
                                            }));
                                        });
                                    },
                                };
                            },
                        };
                    },
                    updated() {
                        return statement.updated();
                    },
                    close() {
                        if (stream) {
                            stream.close();
                        }
                        else {
                            return statement.close();
                        }
                    },
                };
                return stWrap;
            })
                .catch((0, handleError_1.handleError)({ sql, params }));
        },
        update(sql, params) {
            const jsonParams = paramsToJson(params || []);
            return jdbcConnection
                .update(sql, jsonParams)
                .catch((0, handleError_1.handleError)({ sql, params }));
        },
        createWriteStream(sql, options) {
            return (0, jdbcwritestream_1.createJdbcWriteStream)(baseConnection.batchUpdate, sql, options && options.bufferSize);
        },
        batchUpdate(sql, paramsList) {
            const params = (paramsList || []).map((row) => {
                return row.map(convertDateValues);
            });
            const jsonParams = JSON.stringify(params);
            return jdbcConnection
                .batchUpdate(sql, jsonParams)
                .then((res) => Array.from(res))
                .catch((0, handleError_1.handleError)({ sql, params }));
        },
        insertAndGetId(sql, params) {
            const jsonParams = paramsToJson(params || []);
            return jdbcConnection
                .insertAndGetId(sql, jsonParams)
                .catch((0, handleError_1.handleError)({ sql, params }));
        },
        insertList(tableName, idColumn, list) {
            return insertListFun(baseConnection)(tableName, idColumn, list);
        },
        isInMemory() {
            return inMemory;
        },
    };
    return baseConnection;
};
exports.createBaseConnection = createBaseConnection;
//# sourceMappingURL=baseConnection.js.map